\chapter{System Setup}
    One of the main aspects we sought when designing the project was making the installation procedure as simple as possible. The following sections describe how to install and configure all the necessary tools. We will assume the target system is running a \textit{Debian-based} distribution. If that is not the case, we encourage the reader to query his or her distribution's documentation to find out what package manager to use instead of \textit{apt}. Common examples are \textit{dnf} and \textit{pacman} for \textit{Fedora} and \textit{Arch-based} distributions, respectively. Some package names might slightly differ as well: beware.\\

    \section{Installing External Dependencies}
        We will describe how one can check whether the necessary tools are present or not. After that, we include listing \ref{lst:dependency-installation}, which contains the necessary commands to install each of the components in case they are not already present. Note several of the commands contain a leading \textit{sudo} to signify they will require elevated privileges. This might however not be needed in case it is \textit{root} him or herself who is running these commands.\\

        \subsection{iproute2}
            This project \textbf{requires} a machine running the \textit{linux kernel}. Most modern linux distributions will ship with the \textit{iproute2} suite preinstalled, but if that is not the case it needs to be installed. In order to determine whether \textit{iproute2} is available one can run \texttt{which ip}. If the command's output is \textbf{not} empty, the necessary tools are present.\\

        \subsection{Docker}
            Once can run \texttt{docker --version} to determine whether it is present on the system or not. We are including the necessary commands to acquire it on listing \ref{lst:dependency-installation}, but we encourage the reader to visit \cite{bib:docker-install} as it contains a more comprehensive explanation on the process.\\

        \subsection{PIP}
            \textit{PIP} is \textit{python's} package manager. Running \texttt{\allowbreak python3 -m pip --version} aides in determining whether it is present on the system or not. If it is, a message containing information on \textit{PIP's} version will be printed.\\

        \subsection{Python Modules}
            Our tool depends on both the \textit{matplotlib} and \textit{networkx} modules. Once \textit{PIP} is installed on the system we can run \texttt{\allowbreak python3 -m pip list | grep <module-name>} to determine whether module \textit{<module-name>} is present on the system or not. If the previous command shows no output, the specified module is not present on the system. Note listing \ref{lst:dependency-installation} explicitly uses \textit{sudo} when installing these modules. We delve a little deeper into that fact in a later section.\\

        \begin{lstlisting}[language = bash, caption = Commands for installing needed dependencies., label = lst:dependency-installation]
            # If any packages are to be installed with apt,
                # update the repositories.
            sudo apt update

            # Installing iproute2
            sudo apt install iproute2

            # Installing docker
                # Auxiliary packages
                sudo apt install \
                    apt-transport-https \
                    ca-certificates \
                    curl \
                    gnupg \
                    lsb-release

                # Obtaining Docker's repository GPG key
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
                    | sudo gpg --dearmor -o \
                    /usr/share/keyrings/docker-archive-keyring.gpg

                # Adding Docker's repository to the system
                echo \
                    "deb [arch=amd64 signed-by=/usr/share/keyrings/ \
                        docker-archive-keyring.gpg] https://download \
                        .docker.com/linux/ubuntu $(lsb_release -cs) \
                        stable" | sudo tee /etc/apt/sources.list.d/ \
                        docker.list > /dev/null

                # Updating the repositories
                sudo apt update

                # Installing docker itself
                sudo apt install docker-ce docker-ce-cli containerd.io

            # Installing PIP
            sudo apt install python3-pip

            # Installing python modules matplotlib and networkx
                # Note the can be installed separately.
            sudo python3 -m pip install matplotlib networkx
        \end{lstlisting}

    \section{A note on Capabilities}
        On section \ref{sec:user-manual} we already introduced the term \textit{capability}. As seen on \cite{bib:man-capabilities}, \textit{capabilities} allow for a finer control so as to what a process can and cannot do. What is more, a process spawned by a non-privileged user can take actions traditionally reserved for those started by a privileged user as long as it is granted the necessary capabilities. The reader might recall listing \ref{lst:running-nodes} in which we were explicitly assigning several capabilities to the containers we were spawning so that they could perform several needed actions. One of the benefits of using containers is that they allow for a tighter control on what the process running within them can and cannot do. That is why they do are not granted all the capabilities by default.\\

        Capabilities are a feature of the linux kernel, and thus they can be applied to other scenarios. One of the conditions for running our program set forth in section \ref{sec:user-manual} was that it needed to be executed as \textit{root}. The limitation was imposed by the need to leverage the \textit{iproute2} suite for the configuration of the network interfaces associated to the containers. Now, if we apply the concept of capabilities to this particular case we can free ourselves from such a limitation. Given we are passing strings to the \texttt{os.system()} function we are exposing the host to injection attacks through, for example, malicious node names. Listing \ref{lst:injection-atk} contains one such example.\\

        A key piece of information extracted from \cite{bib:man-capabilities} is shown on listing \ref{lst:exec-caps}. It shows how the capabilities of a process are transformed when a call to \texttt{execve()} \cite{bib:man-execve} takes place. Given how shells such as \textit{bash} \cite{bib:man-bash} work, they rely on \texttt{execve()} for launching other programs, which implies the rules set forth on listing \ref{lst:exec-caps} are of the utmost importance.\\

        \begin{lstlisting}[language = {}, caption = Transformation of Capabilities During \texttt{execve()}., label = lst:exec-caps]
            P'(ambient)     = (file is privileged) ? 0 : P(ambient)
            P'(permitted)   = (P(inheritable) & F(inheritable)) |
                                (F(permitted) & P(bounding)) | P'(ambient)
            P'(effective)   = F(effective) ? P'(permitted) : P'(ambient)
            P'(inheritable) = P(inheritable)    [i.e., unchanged]
            P'(bounding)    = P(bounding)       [i.e., unchanged]
            where:
                P()       denotes the value of a thread capability set before
                              the execve(2)
                P'()      denotes the value of a thread capability set after
                              the execve(2)
                F()       denotes a file capability set
                &         denotes the AND logical operation between sets.
                |         denotes the OR logical operation between sets.
                A ? B : C denotes an IF-ELSE close that can be read as: if
                              A is TRUE then B ELSE C.
        \end{lstlisting}

        Given the contents of listing \ref{lst:exec-caps} one might feel overwhelmed. The key idea is to somehow make sure that the processes effective set (i.e. \texttt{P'(effective)}) contains the capabilities we want to grant. In our case we seek granting the \textit{CAP\_NET\_ADMIN} capability to the host's \textit{iproute2} binary. This would imply that we would no longer need to run our program as \texttt{root} \footnote{Disabling the calls to \textit{iptables} as discussed on section \ref{sec:bridge-caveats} would still require privileges. This can nonetheless be done manually without impacting the tool's main use.}, thus denying a huge attack vector.\\

        We must begin by locating the \texttt{ip} binary within the system. This can easily be accomplished by running \texttt{\allowbreak readlink \$(which ip)}. This command will either show the real path to the \texttt{ip} or show no output. In the latter case, the binary's real path is given by \texttt{which ip}. In our case on a machine running \textit{Ubuntu 20.04} \texttt{which ip} returns \texttt{/usr/sbin/ip} which is a symbolic link to \texttt{/bin/ip}, the real executable.\\

        Now that we have located the program itself we need to make sure that \textit{CAP\_NET\_ADMIN} makes its way to the \texttt{P'(effective)} set. This implies the \textit{effective} (i.e. \texttt{F(effective)}) flag must be set for \texttt{/bin/ip} and that \textit{CAP\_NET\_ADMIN} should belong to \texttt{P'(permitted)}. In order for this to be true, the \textit{CAP\_NET\_ADMIN} capability must belong to the file's \textit{permitted} (i.e. \texttt{F(permitted)}) set and the same capability must belong to the \texttt{P(bounding)} set.\\

        These changes can be made effective through the \texttt{setcap} \cite{bib:man-setcap} command. Running \texttt{sudo setcap cap\_net\_admin+ep /bin/ip} does indeed configure the capabilities as shown by the output of \texttt{getcap /bin/ip} \cite{bib:man-getcap}. On top of that, we can leverage the \texttt{capsh --print} \cite{bib:man-capsh} command to query the current process' (i.e. the \textit{shell's}) \textit{bounding} capabilities (i.e. \texttt{P(bounding)}) to indeed check that \textit{CAP\_NET\_ADMIN} belongs to it. To the extent of what we know this would need to be sufficient to be able to leverage \texttt{ip} to carry out network-related tasks. To our uttermost surprise, it was not.\\

        If one browses \textit{iproute2's} source code on \cite{bib:iproute2-src} line $181$ on file \textit{iproute2/ip/ip.c} \footnote{\url{https://github.com/shemminger/iproute2/blob/main/ip/ip.c\#L181}} has a suspicious looking name. The definition of the \texttt{drop\_cap()} function called on it is found on lines $1571 \to 1597$ of file \textit{iproute2/lib/utils.c} \footnote{\url{https://github.com/shemminger/iproute2/blob/main/lib/utils.c\#L1571-L1597}} and is included on listing \ref{lst:drop-cap} for convenience. The key aspect to note is that the function checks whether the \textit{CAP\_NET\_ADMIN} capability belongs to the process' \textit{inheritable} set (i.e. \texttt{P'(inheritable)}) as we have already \texttt{execve()}ed from the shell. Given this set remains unchanged, we can rest assured \texttt{ip} is effectively checking whether the \textit{CAP\_NET\_ADMIN} capability belonged to the shell's \textit{inheritable} set (i.e. \texttt{P(inheritable)}). As that was \textbf{not} the case (we had not modified the shell's binary) then the check on line $18$ of listing \ref{lst:drop-cap} evaluates to \texttt{true == 1}, which makes makes \texttt{ip} drop \textbf{all} the capabilities we have explicitly provided through \texttt{setcap}.\\

        \lstinputlisting[language = c, caption = Defintion of the \texttt{drop\_cap()} Function., label = lst:drop-cap]{Code_snippets/drop_cap.c}

        The check on line $18$ opens up a door for executing \texttt{ip} with the aid of capabilities. When we read the \texttt{drop\_cap()} function we began wondering the motivation behind it. Given our approach of adding the \textit{CAP\_NET\_ADMIN} capability to both the \textit{effective} and \textit{permitted} sets for \texttt{/bin/ip}, we are effectively allowing any user modify the machine's network configuration. This poses a potential security risk. In our quest for a solution to this limitation we encountered a solution that circumvents this issue whilst allowing a more fine grained approach to the management of capabilities.\\

    \section{Acquiring the Project's Code}
        \subsection{Leveraging \texttt{git}}
            \subsubsection{Cloning the Repository}
            \subsubsection{Proposing Changes}
    \section{Framework Code}