\chapter{Used Technology Analysis}
    According to the discussion in the previous chapter we have settled on docker containers running Ubuntu for providing the backbone of our virtualized networks. Now, once we are clear so as to what technology to employ we need to get down to the nitty gritty of implementing a full-fledged virtual network infrastructure. In order to do so we need to become acquainted with the Linux kernel.

    \section{Enter the Network Stack}
        A fascinating but rather messy image is \href{https://upload.wikimedia.org/wikipedia/commons/5/5b/Linux_kernel_map.png}{Linux's "Map"}. If we pay close attention we'll see how one of the columns is just devoted to networking. The software entities comprising this column is what we will refer to as \textit{Linux's Network Stack}\\

         The word stack is something that shows up time and time again in the area of networking. It helps us have a top-level view of how logical entities cooperate within a network. When we think about stacks we naturally begin to consider them in terms of the layers they are composed by, with each layer tackling a simple task and offering services to the layer above whilst using those provided by the layer below. It's not going to be any different with Linux; we can think of its network stack as a huge "blob" of code which all network packets reaching a Linux-based system traverse. Thus, if we can alter how Linux processes packets or build "virtual" connections between different network stacks we would be capable of constructing a de-facto virtual network tailored to our needs.\\

         \paragraph{Naming Packets}
            Before we go on we need to shed some light on the naming we are going to use regarding the units of data exchanged through network links. Even though the term packet is tremendously generic we feel it's not a wrong one to turn to in our case. When we wire up several network nodes together we are looking for full connectivity, that is, connectivity at the application level. Thus, we are not really that interested on what layer the "packet" is at, we don't really care if the packet is a \texttt{segment}, \texttt{datagram} or \texttt{frame}. In the case a need for more specific naming turns up we won't hesitate to use it but we prefer to keep the writing simple and avoiding getting bogged down with technicalities where we feel the benefit is not that obvious.

            A prime example of the above would be the use of the term \texttt{packet} instead of \texttt{link-layer frame} in the section's introduction. \texttt{Frame} is the correct term for referring to the data structure a \texttt{NIC} (Network Interface Card) hands to the kernel (albeit somewhat processed as the preamble and Frame Check Sequence of Ethernet frames are usually stripped from incoming frames by the \texttt{NIC} itself as seen \href{https://gitlab.com/wireshark/wireshark/-/wikis/Ethernet}{here}).

        If we think about network stacks, we would probably believe we need to have one per machine. That is, every network-capable devices must have their own \textit{data-path} which packets are to traverse. What may not be so simple is thinking that a machine \textit{may} have more than one network stack. In order to get a firmer grasp on the implications of the above idea let's revisit the world of network interfaces.\\

        When we first started learning about network architectures we where boggled by the fact that a machine could have more than one NIC. This implied it had several different IP addresses "attached" to it which provided redundancy amongst other several capabilities like traffic control. What astonished us the most was the raw power of not imposing a limit on the number of NICs a machine could have. That simple fact allowed routers to exist for instance and you could do "silly" stuff such as getting a packet through an interface and \texttt{echoing} it out the other. All in all, it provided loads of flexibility to the whole system.\\

        Now, if we transpose the above to the concept of network stacks we could be talking about packets being interchanged in between them whilst residing on the same machine nonetheless. If we sit back and take a look at the larger picture we can clearly see that packet exchanges below the application level are logically switched between network stacks belonging to different machines as it's the stack who's in charge of processing said data structures. Seeing matters in that light and knowing we can have several network stacks on a single platform, talking about packets being interchanged within a machine doesn't seem that far fetched now.\\

        Given the previous discussion we can now clearly see the base on which everything else is built upon. The ability to have several coexisting network stacks on a machine and being able to connect them as we please is such a powerful tool that our work is only scratching the surface of the capabilities enabled by this kind of technology. Linux's network stacks are nothing short of an ode to code modularity if you ask us.\\

        All the previous discussion is related with the theoretical or conceptual realm of matters. We will now delve into how we can translate these ideas into a working virtual network. After going through that process we'll also look into how we decided to do everything manually once we have a broader technical background on the subject.\\

        Finally, we feel we need to clarify that, even though it may be clear at this point, all the network traffic we are to generate originates from within our own system. In other words, our network would be perfectly capable of working without any Internet access.\\

    \section{The Network Namespace}
        % \pyfile{Code_snippets/foo.py}

        % Just as we have previously discussed, design and implementation are two very different things. A prime example is the case of the \texttt{SNMP} tools where \texttt{SNMP} stands for \texttt{Simple Network Management Protocol}. This protocol was originally defined in \href{https://tools.ietf.org/html/rfc1067}{RFC 1067} but no implementation was defined. With time, the \texttt{net-snmp} suite of tools became the de-facto implementation for \texttt{SNMP}. It is then of the utmost importance to notice that the design and implementation needn't be carried out by the same people; in fact, it's not uncommon to have several implementations for a given design. That's the case with shells of which we have so many, \texttt{bash}, \texttt{zsh}, \texttt{ksh} and so on. Then, we can expect the Linux...\\

        Many of the programming languages dominating today's market are object oriented. This, very roughly, means that the programmer is expected to generate \textit{classes} representing "real-life" entities to some extent. These classes are defined by their \textit{attributes} (characteristics) and their \textit{methods} (what they can do). Now, a class by itself cannot do anything, we need to \textit{instantiate} it so that we create an \textit{object} of that class. We'll then be capable of using the newly created object as we please.\\

        This concept of instantiation is actually quite powerful as it appears continuously in many areas of engineering. Now, we could say that Linux's network namespaces work in a similar fashion to classes. We can think of the network stack as the class and what we call \textit{network namespaces} as the objects. Let's delve a bit deeper into what these namespaces really are.\\

        As seen \href{https://en.wikipedia.org/wiki/Linux_namespaces}{here}, namespaces are not only seen when doing networking stuff, they are a feature of the Linux kernel employed in many other areas. These namespaces let us partition kernel resources so that each process sees a resource that's only for it, it's not shared. When applied to networking we can see how each network namespace represents an entire network stack. Then, if we set up several network namespaces (namespaces from now on as this is the only type of namespace we will deal with) we have effectively housed several network stacks under the same roof. If there was any way of interconnecting these namespaces we would have taken quite a dent off our task.\\

        We will now take a look at the virtual wires we have fought so many times against, the so called \texttt{veths}.\\

    \section{Wire time}
        In a previous section we already provided some comments on what NICs are. Knowing that interfaces create "bridges" between different systems we can clearly see how these network interfaces bridge digital systems to a communication network; they let these digital machines leverage the communication capacities of computer networks.\\

        Whilst almost all engineers could recognize what a NIC physically is, the matter is not that simple regarding how the OS treats these interfaces. We find it quite helpful to think of what we would do if we had to implement some software solutions that had to employ network's capabilities. There must be a "way" that these hardware components can be used from the application perspective, that is, the OS needs to offer some kind of abstraction through which we can make use of the NIC itself. This abstraction is what we will call a OS-level NIC or network interface.\\

        Before delving any deeper into this matter we need to discuss what the \texttt{iproute2} suite, as it's through it that we'll control the entire virtual network infrastructure we are to work with.

        \subsection{Meeting \texttt{iproute2}}
            The time we spend on terminal emulators has exponentially increased as we worked our way through our bachelor's. Even though they provide quite a fast way to "get around" the computer they can be a little abstract at times. We are always aware that the OS "under" us has many running processes and provides us with services that can be used at our request. The thing is, faith can at times be scarce so we usually have tools that can inform us about what's going on "behind the scenes". This is the case for programs like \texttt{ps} which reports the status of the system's processes or \texttt{w} which tells us about who is currently logged on the system as well as what they are up to. When using a shell we are aware of the fact that other processes are running and that other users may be logged in but we nonetheless have tools that let us consult the current status of the system.\\

            Where networking is concerned, \texttt{iproute2} is like a Swiss Army Knife. It's a \textit{suite} or collection of tools that lets us do everything from inspecting the current interfaces and routes to generating \texttt{IPv6/IPv4} tunnels. We'll only be concerned with the \texttt{ip} command in our case which is in charge of "showing/manipulating routing tables, network devices, interfaces and tunnels" as seen in \texttt{ip}'s manpage (which can be consulted with \texttt{man ip}). The uses one can give to \texttt{iproute2} are seemingly endless, but before getting into them we believe it would be useful to compare the \texttt{iproute2} suite to its predecessor: \texttt{net-tools}.

            \subsubsection{The ever pervasive \texttt{ifconfig}}
                Querying a system's interfaces is a very common task in the day of a network engineer. Whenever internet connectivity is playing up or network connections don't seem to be working as intended, our initial step is to check interfaces are configured as they should. On \texttt{unix-based} systems such as \texttt{macOS} and \texttt{GUN/Linux} this was traditionally accomplished with the \texttt{ifconfig} command. Before \texttt{iproute2} was implemented, network-related tools fulfilling the same purpose were provided by the \texttt{net-tools} suite. Among the most well-known tools provided by it we can mention \texttt{ifconfig} and \texttt{netstat}. The former displayed information on the system's network interfaces whilst the latter shed light on the open sockets in the system. When working with network-centric applications such as web-servers, \texttt{netstat} was a superb way of finding out whether some process had \texttt{binded} (i.e. began listening) to the \texttt{80} or \texttt{443} ports, each being the default for the \texttt{HTTP} and \texttt{HTTPS} protocols, respectively. With time, \texttt{iproute2} became available and it \textit{deprecated} the \texttt{net-tools} suite. We have nonetheless observed throughout our studies that a non-negligible amount of people are reluctant to abandon \texttt{ifconfig} and related tools.

                What we are trying to achieve with this project is possible if leveraging \texttt{net-tools} instead of \texttt{iproute2}. However, the former's documentation and examples tend to be more cryptic and harder to digest. What's more, even though people resist to stop using it, \texttt{net-tools} is bound to disappear. That's why using the newer network tools confers a longer life prospect to our tool.

                Even though \texttt{net-tools} has been deprecated on \texttt{linux-based} systems, it's still the selected network tool suite for systems such as \texttt{macOS} where \texttt{iproute2} is \textbf{available}. Some programs such as \texttt{iproute2mac} do exist for this operating system, but they just \textit{parse} (i.e. process) the output provided by \texttt{net-tools} utilities and present it following \texttt{iproute2}'s format. We mustn't be deceived by looks: \texttt{iproute2} is a part of \textbf{\texttt{linux}} systems.

                We compare both suites on the table \ref{tab:net-tools-vs-iproute2} as provided by \href{https://www.thegeekdiary.com/comparing-net-tools-v-s-iproute-package-commands/}{this site}.

                \begin{table}
                    \centering
                    \begin{tabular}
                        \hline
                        \textbf{\texttt{net-tools}} & \textbf{\texttt{iproute2}}\\
                        \hline
                        \texttt{arp} & \texttt{ip neigh}\\
                        \hline
                        \texttt{ifconfig} & \texttt{ip addr} \& \texttt{ip link} \& \texttt{ip tunnel}\\
                        \hline
                        \texttt{netstat} & \texttt{ss} \& \texttt{ip maddr}\\
                        \hline
                        \texttt{route} & \texttt{ip route}\\
                        \hline
                    \end{tabular}
                    \caption{\texttt{net-tools} utils vs. \texttt{iproute2}'s}
                    \label{tab:net-tools-vs-iproute2}
                \end{table}

            Knowing a bit about what \texttt{iproute2} is, we believe walking through some examples showing how to instantiate virtual network elements will prove rather revealing.

    \section{Instantiating virtual network elements}
        As \texttt{iproute2} offers us total control over a machine's internal network infrastructure, we believe the best way to showcase what we can do is through example. Before getting down to the "command level" of things, let's get some naming conventions out of the way.

        \subsection{Naming network elements}
            The networks we'll work with are rather simple when it comes to the type elements they are composed of. Even though they can grow quite large, from a network architecture point of view they'll reuse the same components over and over. These components are:

            \begin{itemize}
                \item \textbf{\texttt{Link-level bridges}:} These \textit{layer 2} devices will forward \textit{link-layer frames} within a subnetwork based on the destination \texttt{MAC address}. These are \textbf{transparent} to \textit{layer 3} (i.e. \textit{network}) protocols such as \texttt{IP}. These are implemented as a \texttt{linux bridge} which, in turn, manifests itself as a network interface. They'll provide the backbone for each of the subnets we are to instantiate as they provide their very own broadcast domain. One can find documentation regarding these bridges \href{https://wiki.linuxfoundation.org/networking/bridge}{here}.

                \item \textbf{\texttt{Network-level routers} and \texttt{firewalls}:} These \textit{layer 3} devices will forward packets between subnetworks based on the destination \texttt{IP} address. These will be implemented as \texttt{containers} running a regular \texttt{ubuntu} image. Given these routers sit between subnetworks, we will also implement any required firewall functionality within them as well. We'll delve deeper into how this can be accomplished in due time, but we can say that these firewalls are based on \texttt{iptables}.

                \item \textbf{\texttt{End hosts}:} These are the end systems in the network. They'll be implemented as \texttt{docker containers} as well.

                \item \textbf{\texttt{Veths}:} These are \textit{virtual Ethernet interfaces} which we'll use to wire the entire network together. Note we had only described standalone elements up to now without any means of interconnecting them! These virtual interfaces can be regarded as "virtual wires" with two ends. Any frame coming into one end comes out the other and vice-versa. We can then conclude they behave exactly like real-world wires. We'll then "insert" one end of a \texttt{veth} into a network device and the other end into another one to effectively "wire them together".

                \item \textbf{\texttt{Network namespace}:} We would like to make it absolutely clear that \textit{namespaces} are \textbf{not} network devices per-se: they have no real world counterpart. As we'll later see, each \texttt{container} spawns its own \textit{namespace}: we have a one-to-one correspondence between hosts/routers and namespaces. This will be crucial when "wiring things up" with \texttt{veths}, as they'll have to be associated to a particular network namespace for things to work. We know some concepts might seem hazy at best for now: we promise things will clear up in due time.
            \end{itemize}

        % TODO: Add iproute2 examples from the wiki's documentation!