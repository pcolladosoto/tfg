\chapter{Automating the Deployment of Virtual Networks} \label{chap:4}
    \section{High Level Overview}
        As seen in chapter \ref{chap:3}, bringing a virtual network up entails an organizational overhead that is not easily handled. That is why we have developed a complete software system capable of handling these intricacies in an automatic fashion. Then, a user need only provide a \texttt{graph} describing the desired topology and our project will be able to read, interpret and instantiate said network.\\

        Due to its simple yet rich syntax, we have decided to leverage the \href{https://www.python.org}{\texttt{Python}} programming language to develop the entire system. We will be using version \texttt{3.x} given \texttt{python}'s \texttt{2.7} release has been deprecated as of \textit{January 2021}. One of the external dependencies we will make use of is the \href{https://networkx.org}{\texttt{NetworkX}} network analysis module. This software bundle was recommended by the research group we have collaborated with and it is distributed as a \texttt{python package}. Thus, we felt even more inclined towards \texttt{python}. Given we will interact with the \texttt{docker engine} through its \texttt{CLI API}, its use will not impose any restrictions on our choice either. This implies that we have nothing more than reasons supporting the use of \texttt{python} for our development.\\

        \subsection{External Dependencies}
            One of the main objectives pursued throughout the development was reducing the number of external dependencies to the maximum extent. We did manage to only require the presence of \texttt{docker}, \texttt{iproute2} and \texttt{python3} for an initial and fully functional version. Not leveraging \texttt{NetworkX} implied we had to manually route all the nodes within the network, which amounted to be a rather complex task. Due to the research group's suggestions we settled on taking advantage of \texttt{NetworkX} for both modeling the different topologies and routing them. Then, we have designed two independent solutions that accomplish the same task. One of them \textbf{does not} require \texttt{NetworkX} whist the other one \textbf{does}. The reasoning behind including a dependency that is not strictly needed is that it greatly simplifies our code and it will surely avoid some of the most common pitfalls our own solution can incur into under complex circumstances.\\

            The following enumeration briefly explains the use of each of the required dependencies. Please bear in mind that the installation instructions for each of them are detailed in the document's appendix.\\

            \begin{enumerate}
                \item \textbf{\texttt{Python3}:} With \texttt{python3} being an interpreted language, we need to make use of the interpreter that is going to execute our code.
                \item \textbf{\texttt{Docker}:} The different nodes in our network are modeled as \texttt{docker containers}, which implies we indeed depend on \texttt{docker} for making our system work.
                \item \textbf{\texttt{IpRoute2}:} We need the \texttt{iproute2} suite of tools to manage the virtual networking infrastructure ``gluing'' all our nodes together.
                \item \textbf{\texttt{NetworkX}:} As explained above, we \textit{are not forced} to use \texttt{NetworkX} and we have developed a version that does not depend on it at all. Nonetheless, it does simplify big portions of code and so we decided to include it in our final, sharper version.
                \item \textbf{\texttt{Matplotlib}:} \texttt{NetworkX} is capable of graphically representing our topologies through \textit{graphs}. In order to ``draw them'', \texttt{NetworkX} depends on the \texttt{matplotlib} module we have also installed as a dependency. This module is however \textbf{not mandatory}: they rest of the program will work as intended, it will just be unable to graphically represent the topology. In a later chapter we will devote our time to looking into a \textit{proof of concept} we have developed. Said experiment generates a series of time-tagged events that our program is capable of representing as a regular graph. The lack of the \texttt{matplotlib} module implies this graph will not be available either. All in all, it is up to the user to decide whether they want this functionality or not: the program itself will carry out is primary task either way.
                \item \textbf{\texttt{Docker Python SDK}:} We \textbf{have not} used the \texttt{docker python SDK} (\texttt{S}oftware \texttt{D}evelopment \texttt{K}it) in our project. We have decide to leverage \texttt{docker}'s \texttt{CLI} interface from our code through calls to \texttt{os.system()}. However, someone deciding to use our project as a basis for something else might feel more comfortable interacting with \texttt{docker} through a pure-\texttt{python} \texttt{API} (\texttt{A}pplication \texttt{P}rogramming \texttt{I}nterface). Changing our code to work in said fashion is a rather simple task should it have to be done.
            \end{enumerate}

        \subsection{User Manual}
            Throughout the development of our tool we have tried to simplify the use of the project as much as possible. The end result is a user-side workflow that only requires them to import a single project module to which they \textbf{must} provide a \texttt{NetworkX graph}. After doing so, they will be presented with a simple \texttt{CLI} letting them modify the currently live virtual network.\\

            \paragraph{User Permissions}
                Given the project will make use of \texttt{iproute2} the program needs to be run with administrative privileges (i.e. prepended by \texttt{sudo}). Even though this is the easiest approach and everything will ``just work'' it does have some security implications (mainly command injection) we will showcase in the appendix. Instead of choosing to run the entire blob of code as \texttt{root} we can also grant certain capabilities to the user who is to run the code, namely the \texttt{NET\_ADMIN} capability (the same we need to grant containers). We should also mention that the user running the program must be able to interact with the \texttt{docker engine}. This can be ensured by adding said user to the \texttt{docker group} within the system, even though \texttt{root} will also be able to interact with and manage containers. This paragraph is intended as a warning, please refer to the appendix for a deeper discussion.\\

            Depending on how the users decide to provide the required \texttt{graph} they might need to import additional modules. If they have stored a live graph as a \href{https://docs.python.org/3/library/pickle.html}{\texttt{pickle}} they will then need to import the \texttt{pickle} module to \texttt{un-pickle} the graph, for instance. In our examples we will define the graphs ``on-the-fly'', which requires us to import \texttt{networkx} itself. Listing \ref{lst:sample-topology-graph} shows how one would define the topology found on figure \ref{fig:sample-topology} as a \texttt{networkx} graph.\\

            \begin{lstlisting}[language = python, caption = Defining the Sample Topology as a \texttt{networkx} graph., label = lst:sample-topology-graph]
                # Import the networkx module so that we can define a graph.
                import networkx

                # Instantiate the netowrkx.Graph class.
                sample_net = networkx.Graph(net = 'Sample Topology')

                # Add host H-A-1 and the bridge for subnet A.
                sample_net.add_node('h-a-1', type = 'node')
                sample_net.add_node('subnet-a-brd', type = 'bridge', subnet = '10.0.0.0/24')

                # Add host H-B-1 and the bridge for subnet B.
                sample_net.add_node('h-b-1', type = 'node')
                sample_net.add_node('subnet-b-brd', type = 'bridge', subnet = '10.0.1.0/24')

                # Add the R-A-B router with NO firewall rules.
                sample_net.add_node('r-a-b', type = 'router', fw_rules = {})

                # Connect H-A-1 to the bridge for subnet A.
                sample_net.add_edge('h-a-1', 'subnet-a-brd')

                # Connect H-B-1 to the bridge for subnet B.
                sample_net.add_edge('h-b-1', 'subnet-b-brd')

                # Connect router R-A-B to both bridges.
                sample_net.add_edge('subnet-a-brd', 'r-a-b')
                sample_net.add_edge('subnet-b-brd', 'r-a-b')
            \end{lstlisting}

            \subsubsection{Creating Well-formed Graphs}
                Our tool expects the nodes on a \texttt{networkx} graph to adhere to certain constraints so that it can assemble the requested topology. Given the bi-directional nature of network links (data is sent in both directions), we have decided to model our networks as \textbf{undirected graphs}. Then, these will always be composed by a set of \texttt{nodes} interconnected by a set of \texttt{edges}. The types of nodes one can use are listed on table \ref{tab:node-types}.\\

                \begin{table}
                    \centering
                    \begin{tabular}{|c|c|}
                        \hline
                        \textbf{Node Type} & \textbf{Description}\\
                        \hline
                        \texttt{node} & A regular host.\\
                        \hline
                        \texttt{bridge} & A link-layer switch that represents an entire subnetwork.\\
                        \hline
                        \texttt{router} & A net-layer router joining two or more subnetworks together.\\
                        \hline
                    \end{tabular}
                    \caption{Node types.}
                    \label{tab:node-types}
                \end{table}

                When adding a new node one must make sure that the following constraints \textbf{are respected}. Otherwise, all sorts of undefined behavior can and will be experienced: anything from a network that cannot be started to the presence of routing loops can happen.\\

                \begin{enumerate}
                    \item \textbf{Rules regarding node definitions:}
                    \begin{enumerate}
                        \item Each node's name \textbf{MUST} be a \textbf{unique} \texttt{string}.
                        \item Each node \textbf{MUST} contain a \texttt{type} attribute whose value is a \texttt{string}.
                        \item The value of the \texttt{type} attribute \textbf{MUST} be one of \texttt{"node"}, \texttt{"router"} or \texttt{"bridge"}.
                        \item Each bridge \textbf{MUST} contain a \texttt{subnet} attribute.
                        \item Every value for a \texttt{subnet} attribute \textbf{MUST} be specified as a \texttt{string} with the \texttt{"A.B.C.D/E"} format, where $A,\ B,\ C,\ D \in [0,\ 255];\ E \in [0,\ 30]$.
                        \item The subnetwork ranges associated to each bridge through the \texttt{subnet} attribute \textbf{MUST} be \textbf{unique}.
                        \item Each router \textbf{MUST} contain a \texttt{fw\_rules} attribute.
                        \item Each \texttt{fw\_rules} attribute \textbf{MUST} be set to a \texttt{dictionary} complying to the specifications laid out in section \ref{sec:fw-rules}.
                    \end{enumerate}
                    \item \textbf{Rules regarding edge definitions:}
                    \begin{enumerate}
                        \item The \texttt{strings} used to identify the nodes to be joined by an edge \textbf{MUST} refer to previously defined nodes.
                    \end{enumerate}
                    \item \textbf{Rules regarding the topology:}
                    \begin{enumerate}
                        \item Each subnetwork is \textbf{MUST} be composed by a \textbf{single} switch and an arbitrary number of nodes and/or routers.
                    \end{enumerate}
                \end{enumerate}

            \subsubsection{Running a Graph}
                Once we have defined a graph as we have done on listing \ref{lst:sample-topology-graph} we just need to run it to turn it into a virtual network. This can be accomplished though the \texttt{launch\_net()} function we have defined on the \texttt{net\_tools} module. We will of course analyze these in a later section.\\

                Listing \ref{lst:running-a-graph} shows how a use can run an existing \texttt{networkx} graph like the one defined on listing \ref{lst:sample-topology-graph}.\\

                \begin{lstlisting}[language = python, caption = Turning a graph into a virtual network., label = lst:running-a-graph]
                    # Importing our module to launch the virtual network
                    from net_tools import net_ctrl

                    # This line will trigger the virtual network's creation.
                        # The second parameter controls whether we enable
                        # the configured firewalls or not.
                    net_ctrl.launch_net(sample_net, fw_on = False)
                \end{lstlisting}

            \subsubsection{Configuring Firewalls} \label{sec:fw-rules}
                When configuring router \texttt{R-A-B} on listing \ref{lst:sample-topology-graph} we passed an empty \texttt{dictionary} \texttt{\{\}} to the \texttt{fw\_rules} parameter thus effectively disabling the firewall of said router.\\

                In order to define appropriate rules, the user needs to provide a \texttt{dictionary} adhering to the syntax specification shown on listing \ref{lst:fw-dict-syntax}.\\

                \begin{lstlisting}[language = python, caption = Syntax for specifying firewall rules., label = lst:fw-dict-syntax]
                    # Note '|' is to be read as 'OR'
                    fw_rules = {
                        'POLICY': 'DROP' | 'ACCEPT',
                        'ACCEPT': [(RULE_1), (RULE_2), ..., (RULE_N)],
                        'DROP':   [(RULE_A), (RULE_B), ..., (RULE_Z)]
                    }

                    # Each rule has a syntax of the form
                    ('origin_node', 'destination_node', True | False)
                \end{lstlisting}

                \paragraph{Rule Syntax}
                    The first $2$ elements are \texttt{strings} containing the names of the origin and destination nodes, respectively. The third parameter acts as a flag controlling whether the rule is uni or bi-directional. If set to \texttt{False}, we will only instantiate a rule affecting traffic going from the origin to the destination. If it is \texttt{True} however we will also instantiate a symmetric rule allowing for two-way communication. Even though the flag is not \textit{explicitly} needed it does reduce the configuration specification tremendously, as the topologies we worked with always made use of symmetric rules. Listing \ref{lst:sym-vs-uni-fw} shows how one can accomplish the same configuration with two rules instead of one if not using said flag.\\

                    \begin{lstlisting}[language = python, caption = Uni-directional vs. symmetric firewall rules., label = lst:sym-vs-uni-fw]
                        # Enable two-way communication x <--> y.
                        ('x', 'y', True)

                        # This accomplishes the same result with two triplets.
                        ('x', 'y', False)
                        ('y', 'x', False)
                    \end{lstlisting}

                \paragraph{Dictionary Syntax}
                    The \texttt{dictionary} contains $3$ key-value pairs. The first one defines the policy for the \texttt{FORWARDING} chain as a \texttt{string}. The second one contains a \texttt{list} of rules for \texttt{ACCEPT}ing packets. If the default policy is set to \texttt{ACCEPT} these rules will be meaningless... The third one contains a \texttt{list} of rules for \texttt{DROP}ping packets. If the default policy is to \texttt{DROP} them these rules will have no effect either.\\

            \subsubsection{Execution Modes}
                Chapter \ref{chap:5} is devoted to analyzing the \textit{proof of concept} we have developed. Said \textit{proof of concept} will produce a series of files \texttt{CSV} containing data that characterizes how the experiment developed. These files can also be analyzed by our program to provide a nicely formatted output so that the end user can make the most of the results.\\

                Instantiating a full-fledged virtual network when the user only wants to load some \texttt{CSV} files to graph or analyze them can prove to be a rather time and energy consuming process. That is why we have developed the so called \textit{report mode} on top of the \textit{normal} or \textit{network mode}.\\

                The former will cause the program to parse a graph defining a network topology and then instantiate it. This mode can of course carry out the same analysis on files as the \textit{report mode}. The \textit{report mode} on the other hand will just present the user with the \texttt{CLI} where he or she will be able to invoke a subset of all the commands. These are: \texttt{ld-atk-data}, \texttt{atk-graph}, \texttt{c | clear}, \texttt{quit | exit | x} and \texttt{CTRL + C}.

                The advantage \textit{report mode} has over the \textit{normal mode} is that it need not be concerned with instantiating a virtual network. This makes its startup time almost negligible.\\

                In order to enable \textit{report mode}, one can either specify the \texttt{report\_mode = True} parameter on the call to \texttt{launch\_net()} as seen on listing \ref{lst:running-a-graph} or just run the \texttt{net\_ctrl.py} file directly with \texttt{python3 net\_ctrl.py}. The latter approach will trigger an \texttt{if name == "\_\_main\_\_:} clause, thus causing the \texttt{report\_mode} parameter to be set to \texttt{True}. Please note the different files and their purposes will be explained in a later section.\\

            \subsubsection{Available Commands}
                As stated before, our tool will allow the users to modify the virtual network once it is up and running through a \texttt{CLI} interface. The following enumeration contains a list of the available commands together with a short description of what they can achieve.\\

                \begin{enumerate}
                    \item \textbf{\texttt{mvsubn <affected\_subnet> <destination\_subnet>}:} This command will move the \texttt{<affected\_subnet>} and attach it to the \texttt{\allowbreak<destination\_subnet>}. These identifiers should be the ones provided by the \texttt{lssubn}. If either subnet does not exist, the command will fail with an error message.
                    \item \textbf{\texttt{mvnode <affected\_node> <destination\_subnet>}:} This command will move the \texttt{<affected\_node>} to the \texttt{<destination\_subnet>}. These identifiers should be the ones provided by \texttt{lsnode} and \texttt{lssubn}, respectively. If either element does not exist, the command will print an error message.
                    \item \textbf{\texttt{lssubn}:} This command will print a list of all the currently active subnetworks. These identifiers are the ones to be provided to the \texttt{mvsubn} and \texttt{mvnode} commands.
                    \item \textbf{\texttt{lsnode}:} This command will print a list of all the currently active nodes. These identifiers are the ones to be provided to the \texttt{mvnode} command.
                    \item \textbf{\texttt{lsnet}:} This command will graphically represent the current network topology. Please note this call is blocking, so the user will not be able to issue any other command until he or she closes the image. This command will require the installation of the \texttt{matplotlib} dependency. It is also worth mentioning that the generated image can be stored as a \texttt{PNG} file for later inspection.
                    \item \textbf{\texttt{lscnx}:} This command will show a ``higher level graph'' capturing the logical connections set up through firewall rules within the routers belonging to the network. If firewalls have not been enabled, the command will just print an informative message on screen as the resulting graph would be the same as the one shown by the \texttt{lsnet} command, given no logical connections are hampered by firewall rules. Even though one can generate this graph, the user should regard it as more of a ``debugging'' feature. We are internally the data structure from which the graph is derived as means of making dynamic firewall reconfiguration easier.
                    \item \textbf{\texttt{dump-atk-data [path]}:} Running the attack on the scenario generates output through files within the network nodes. This command is in charge of reaping all this data an dumping it both to a file and to a \texttt{dictionary}. Please note that, as the main program is ran as \texttt{root}, the generated files will belong to said user. One can manually change permissions with \texttt{chown} later on. These files contain a list of comma separated values (that is, these are \texttt{CSV} files) that are human readable. Nonetheless, the primary intention of this files is to allow the user to later inspect them and generate graphs through the program itself. In order to do so, we have prepared the so called \texttt{report-mode}. As seen in the command description, one can optionally provide a path to save the file to under \texttt{\allowbreak ../proof\_of\_concept/generated\_data/}. This will usually be just a filename. If this path is not provided, the default name \texttt{last\_data.csv} will be used. Please note that results will overwrite themselves unless the user changes the output file's name.
                    \item \textbf{\texttt{ld-atk-data [path]}:} This command will load the attack data from the default \texttt{\allowbreak../proof\_of\_concept/generated\_data/last\_data.csv} file or the one specified through the optional \texttt{path} parameter. Please note that \texttt{\allowbreak ../proof\_of\_concept/generated\_data} will be prepended to whatever argument is provided. This command will fail if the provided path leads to a non existent file.
                    \item \textbf{\texttt{atk-report}:} This command will read the \texttt{dictionary} containing the attack's results and print a nicely formatted table to \texttt{stdout} showing the times the \texttt{ping} processes went either up or down. In order for it to work, the user must either dump the data previously through \texttt{dump-atk-data} or load it from a file with \texttt{ld-atk-data}. If these steps have not been fulfilled, a nice reminder will be printed to the screen.
                    \item \textbf{\texttt{atk-graph}:} This command will show a graph displaying the evolution of the number of \texttt{ping} processes in the network against time. As before, the data must either be dumped or loaded beforehand.
                    \item \textbf{\texttt{check-atk}:} This command was written to aid in the debugging of the attack script. It will display the number of times the attack has run on each network node. An attack that is behaving as expected will run only once within each node.
                    \item \textbf{\texttt{launch-pings}:} This command will launch a \textit{daemonized} \texttt{ping} process in each node. \textit{Daemonizing} the \texttt{pings} allows them to keep on running after the script moves to a new network node (i.e. it allows ping to run without a controlling \texttt{TTY}).
                    \item \textbf{\texttt{reset-net}:} The attack we have written relies on several output files it generates to keep track of its current state. Thus, running the attack twice may result in some unexpected behaviour. This command will get rid of said files so as to effectively restore the network nodes to their original state.
                    \item \textbf{\texttt{clear | c}:} This command will clear the screen to allow for a more comfortable user experience. If running on a compliant shell, the \texttt{CTRL + L} combination will have the same effect. Note this command can be invoked either via \texttt{clear} or just \texttt{c} as seen in the syntax specification.
                    \item \textbf{\texttt{quit | exit | x}:} This command will dismantle the network and exit the program. Note \texttt{exit} and \texttt{x} are \textit{aliases} for \texttt{quit}.
                    \item \textbf{\texttt{CTRL + C}:} This key combination will send the \texttt{SIGINT} signal to the process which will be handled, causing the program's termination. The user may need to press \texttt{ENTER} so that the program reads it, as the call to \texttt{input()} is blocking and sometimes interferes with the user's input.
                \end{enumerate}

    \section{In-depth Module Analysis}
        One of the principles driving software development is \textit{modularity}. We have then tried to make our code components as independent as possible whilst allowing them to cooperate so that they can be used for other purposes besides the ones that we originally intended.\\

        The development effort culminated on $3$ different modules fulfilling each a set of tasks:

        \begin{enumerate}
            \item \textbf{\texttt{virt\_net}:} This module is concerned with the instantiation of the different network elements (\texttt{veths}, \texttt{bridges} and \texttt{nodes}) together with their addressing and configuration. The module contains classes representing everything from the entire network to a single \texttt{veth}.
            \item \textbf{\texttt{graph\_interpreter}:} This module acts as an intermediary translating the graphs provided by users to instances of the different classes defined in the \texttt{virt\_net} module. It will also implement the high-level functionality provided by user commands such as \texttt{mvsubn} and \texttt{mvnode}. On top of that, it will leverage \texttt{networkx}'s functionality to route the entire network and instantiate said routes in the routers once they have been brought up.
            \item \textbf{\texttt{net\_ctrl}:} This module implements the \texttt{CLI} users running the tool will be presented with. It will resolve issued commands to calls to functions defined in the \texttt{graph\_interpreter} module. This module serves as the user's entry point to the functionality offered by our tool.
        \end{enumerate}

        The design we have just specified allows other users to ``swap'' the modules they do not desire to use for their own or third-party ones. One can, for instance, decide not to use our \texttt{graph\_interpreter} and manually instantiate a network through calls to the \texttt{virt\_net} module alone and that would be completely feasible. We will now include the documentation for each of the modules down to the \textit{function-level}.\\

        \subsection{Conventions}
            \subsubsection{Data Type Specifications}
                The \texttt{C programming language} is by no means user friendly. Nonetheless, there is one aspect we really missed when developing in \texttt{python}: data type specification. In an effort to make the understanding of our code easier we have decided to specified each attribute's and variable's data types in the documentation composing this section. The syntax we will use to describe the used types is:\\

                \begin{itemize}
                    \item \textbf{\texttt{Strings}:} \texttt{string}.
                    \item \textbf{\texttt{Lists}:} \texttt{list/value\_type}.
                    \item \textbf{\texttt{Dictionaries}:} \texttt{dictionary/key\_type/value\_type}.
                    \item \textbf{\texttt{Boolean}:} \texttt{boolean}.
                    \item \textbf{\texttt{Instance of class Foo}:} \texttt{Foo\_inst}.
                \end{itemize}

            \subsubsection{Defining Private Methods}
                One of the main advantages of the object-oriented programming is that it provides ``access control'' to methods and attributes of a class. In \texttt{C++}, this is accomplished by classifying them as \texttt{private} or \texttt{public}, for instance. On the other hand \texttt{python} does not \textit{enforce} this behaviour: a user will be able to call any method or access any attribute of an instance.\\

                In order to ``circumvent'' this issue, the convention has it that method and attribute names prepended by an underscore (\texttt{\_}) are to be treated as private. If a user decides to explicitly call or access these methods and attributes he or she is then exposed to undefined behaviours.\\

            \subsubsection{Calling Methods Through the Module Name}
                We have chosen to always call functions and instantiate classes external to the current file through their full name (i.e. including the name of the external file in the call). This does increase the length of code lines but it allows the reader (and ourselves) to know where the functions and classes are effectively defined. We feel like the increase in line length is completely justified.\\

            \subsubsection{The \texttt{\_\_init\_\_.py} File}
                Each of our modules contains an empty \texttt{\_\_init\_\_.py} file so that they become \texttt{regular packages}. This allows us to comfortably import the modules where their contents are needed. More information on \texttt{python}'s import system can be found \href{https://docs.python.org/3/reference/import.html#regular-packages}{here}.

            \subsubsection{Constructors and Destructors}
                When a \texttt{class} is instanced and it becomes an \texttt{object} one special method will be automatically invoked for us: the \texttt{constructor}. In \texttt{python} this method is \textbf{always} named \texttt{\_\_init\_\_()} and it \textbf{cannot} return anything.\\

                The counterpart of the \texttt{constructor} is the \texttt{destructor}. \texttt{Python} is \textit{garbage collected} in the sense that, once there are no more references to an object, it will schedule it for deletion. When an object is being deleted its \texttt{destructor} will be automatically called as well. This \texttt{destructor} is always defined as \texttt{\_\_del\_\_()} in \texttt{python} and it accepts a single argument: a reference to the instance that is being deleted (i.e. \texttt{self}). Just like the \texttt{constructor}, it \textbf{cannot} return anything.\\

                These methods will be defined for each of our classes and, given the \texttt{\_\_init\_\_()} and \texttt{\_\_del\_\_()} names can come across as rather cryptic we have decided to denote them as \texttt{constructor} and \texttt{destructor}, respectively, in the following sections.\\

        \subsection{The \texttt{virt\_net} Module}
            \subsubsection{\texttt{Constants.py}}
                In an effort to reduce the number of dependencies we decided to leverage \href{https://en.wikipedia.org/wiki/ANSI_escape_code}{\texttt{ANSI Escape Codes}} to colorize the different output messages. This module then defines the different \texttt{strings} controlling the colours.

                \paragraph{Imported Libraries}
                    None as there are no external dependencies.

                \paragraph{Global Variables}
                    \begin{enumerate}
                        \item \textbf{\texttt{terminal\_escape\_sequences (dictionary/string/string)}:} \texttt{Dictionary} keyed by color names whose associated values are \texttt{ANSI Escape Sequences} changing the terminal's output color to the one specified. This solution is \textbf{not} to be considered portable. It \textbf{should} nonetheless work on any regular terminals supporting colors. We can assure it works with the following terminal emulators: \texttt{tilix}, \texttt{kitty} and \texttt{Visual Studio Code's Embedded Terminal Emulator}.
                    \end{enumerate}

            \subsubsection{\texttt{Interface.py}}
                This class will be in charge of providing a node's network functionality. An interface represents a connection with a computer network and thus is defined by a key parameter: the IP address. We should stress how an IP address is associated with an interface, \textbf{not} with the host itself. This subtlety will be extremely relevant when dealing with routers.\\

                Another key aspect of interfaces is the role they play in network routes. Even though it is not entirely correct, in our case we can talk about the interface's routes. If we are being precise we would consider routes to be associated to a machine's network stack, not to a given interface. Nonetheless, as the graphs we are to instantiate will always define topologies in such a way that only an interface per host will belong to a given subnetwork we can indeed associate a route with an interface for a given route will only egress through a specific interface. This distinction will allow us to quickly and univocally query a node's route configuration.\\

                Once an interface is configured it will just support a machine's connections. It is also crucial to note that even though an instance of the \texttt{interface} class is \textbf{not} the same thing as a \texttt{veth}, they are intimately related. Instantiating an \texttt{interface} will trigger the creation of a \texttt{veth} and deleting the former will also remove the latter. All in all, an interface's lifecycle can be described as:\\

                \begin{enumerate}
                    \item An interface instance is created and the associated \texttt{veth} is created as well.
                    \item The interface is assigned an IP address.
                    \item One or more routes are assigned to or deleted from the interface.
                    \item The interface sits idle until it returns to $2$ or $3$ or goes to $5$.
                    \item The interface is removed, which will also remove the corresponding \texttt{veth}.
                \end{enumerate}

                \paragraph{Imported Libraries}
                    \begin{enumerate}
                        \item \textbf{\texttt{os}:} This module enables the execution of commands through a \texttt{sh} shell through the \texttt{os.system()} method. One can check the shell being spawned is indeed \texttt{sh} by running \texttt{\allowbreak os.system("echo \$0")} or bu querying the following \href{https://linux.die.net/man/3/system}{\texttt{manpage}}.
                        \item \textbf{\texttt{constants}:} Grant access to the \texttt{\allowbreak terminal\_escape\_sequences dictionary} containing \texttt{ANSI escape sequences} enabling colored output.
                    \end{enumerate}

                \paragraph{Global Variables}
                    \begin{enumerate}
                        \item \textbf{\texttt{\allowbreak t\_colors - dictionary/string/string}:} This is a synonym for the \texttt{\allowbreak terminal\_escape\_sequences dictionary} we me mentioned before. It is used within calls to \texttt{print()} so that we can alter the terminal text's color allowing for a more visual information representation.
                    \end{enumerate}

                \paragraph{The \texttt{interface} Class}
                    This class represents a host's interface.

                    \subparagraph{Class Attributes}
                        \begin{enumerate}
                            \item \textbf{\texttt{self.host\_name - string}:} Name identifying the host this interface belongs to.
                            \item \textbf{\texttt{self.ip\_range - string}:} Interface's IP and subnetwork mask in \href{https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing}{CIDR} format. Ex: \texttt{"10.0.0.1/24"}.
                            \item \textbf{\texttt{self.ip - string}:} Interface's IP address.
                            \item \textbf{\texttt{self.if\_name - string}:} Interface's name. This is equivalent to traditional names like \texttt{enp2s0} or \texttt{wlp3s0} in Linux-based systems. In our case the names will follow a pattern given by \texttt{veth\_+\_-} where \texttt{+} and \texttt{-} are the names of the connected nodes. Note either \texttt{+} or \texttt{-} will be the same as \texttt{self.host\_name}. We would finally like to point out that \texttt{+} and \texttt{-} can be either upper or lowercase, depending on which is the first node to be attached to the links we create.
                            \item \textbf{\texttt{self.subn\_gateway - string}:} IP address of this subnet's gateway, following the same format as \texttt{self.ip}.
                            \item \textbf{\texttt{self.subn - string}:} Interface's subnetwork given as the network address for said subnetwork together with the subnet mask in \texttt{CIDR} notation. Ex: \texttt{10.0.0.0/24}.
                            \item \textbf{\texttt{self.outbound\_interface - boolean}:} \texttt{True} if the interface's host is allowed to connect to external subnets. \texttt{False} otherwise. Due to how some ICS networks need to isolate some equipment, such as reactor's control systems, we need to know whether a given host is allowed to ``see'' the outside world. Having this information encoded into interfaces allows for a cleaner design when routing the network.
                        \end{enumerate}

                    \subparagraph{The \texttt{Constructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                                \item \texttt{h\_name - string:} The host the interface belongs to.
                                \item \texttt{if\_name - string:} The interface name
                                \item \texttt{subnet - string:} The subnetwork the interface belongs to.
                                \item \texttt{h\_type - boolean:} \texttt{True} if the interface belongs to a regular node, \texttt{False} otherwise.
                                \item \texttt{out\_interface - boolean - optional:} \texttt{True} if the node is allowed to ``see'' other subnetworks, \texttt{False} otherwise.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will initialize the members of an \texttt{interface\_inst} and call the \texttt{\_activate\_iface()} method.
                        \end{enumerate}

                    \subparagraph{The \texttt{\_activate\_iface()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method leverages the \texttt{os.system()} function to activate a \texttt{veth} interface. The \texttt{string} we pass \texttt{os.system()} is built though the concatenation of several instance attributes. As we usually do, we check whether \texttt{os.system()}'s return code was $0$ to show an informative message to the user.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_if\_subnet()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the subnetwork the interface belongs to in \texttt{CIDR} notation.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_if\_ip\_range()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the interface's IP and subnetwork mask in \texttt{CIDR} format.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_if\_ip()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the interface's IP.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_if\_name()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the interface's name.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_routes()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{dictionary/string/string} containing the routes that have been assigned through this interface.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{set\_if\_name()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                                \item \texttt{if\_name - string}
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} Assigns the value of the \texttt{if\_name} parameter to the \texttt{self.if\_name} attribute.
                        \end{enumerate}

                    \subparagraph{The \texttt{assign\_addr()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                                \item \texttt{ip\_range - string:} The interface's IP address together with its subnetwork mask.
                                \item \texttt{gw\_addr - string - optional:} IP address of the subnetwork's gateway (i.e. router).
                                \item \texttt{subnet - string - optional:} The subnet the interface belongs to in \texttt{CIDR} format.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method lets the caller assign an IP address to the interface. The method will check that the interface name is valid and that the interface had no previous address to avoid errors. Note that when a node moves within the network its interface \textbf{will not} be reconfigured: a new one will be added to the node. Once the addressing has been successfully completed a message stating that will be printed.
                        \end{enumerate}

                    \subparagraph{The \texttt{assign\_route()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                                \item \texttt{dest\_subnet - string:} Destination subnetwork for the route in \texttt{CIDR} format.
                                \item \texttt{gw\_router - string:} IP of the gateway for the interface's subnetwork.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} After checking the interface has been assigned an IP address and that it is allowed to communicate with other subnetworks through the \texttt{self.outbound\_interface} attribute it will add the route defined by the parameters to the \texttt{self.routes dictionary}.
                        \end{enumerate}

                    \subparagraph{The \texttt{reset\_interface()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will wipe the \texttt{self.routes dictionary} and remove the interface's IP address. This will also delete any preexisting routes. As usual, an informative message will inform of the operation's success.
                        \end{enumerate}

                    \subparagraph{The \texttt{remove\_interface()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will delete the associated interface, together with all the routes, and print an informative message upon completion.
                        \end{enumerate}

                    \subparagraph{The \texttt{Destructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - interface\_inst:} The actual interface instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will just call \texttt{remove\_interface()}.
                        \end{enumerate}

            \subsubsection{\texttt{Subnet\_Machines.py}}
                This file contains the class definitions for the elements belonging to a subnetwork: \texttt{bridges} and \texttt{nodes}. We would like to clarify that we refer to regular \texttt{hosts} as \texttt{nodes} interchangeably.\\

                We have purposefully decided \textbf{not to consider} \texttt{routers} as part of these subnetworks. The logic behind the decision is that a \texttt{router} belongs to at least two subnetworks in out topologies. Thus, defining its class in a file whose context is that of a single subnetwork did not seem appropriate.\\

                Once again, we should point out how an instance of the \texttt{k\_bridge} class \textbf{is not} the same thing as the actual \texttt{bridge}, but they are intimately related. The following explains the lifecycle of both classes defined in this file.\\

                \begin{enumerate}
                    \item The real instance, either a \texttt{bridge} or a \texttt{host}, is brought up.
                    \item The object representing said instance is created.
                    \item The object sits idle. Several of its parameters can be altered within this state.
                    \item At some point, the object will be dismantled.
                    \item The release of the object will trigger the removal of the associated real instance.
                \end{enumerate}

                \paragraph{Imported Libraries}
                    \begin{enumerate}
                        \item \textbf{\texttt{os}:} This module enables the execution of commands through a \texttt{sh} shell through the \texttt{os.system()} method. One can check the shell being spawned is indeed \texttt{sh} by running \texttt{\allowbreak os.system("echo \$0")} or bu querying the following \href{https://linux.die.net/man/3/system}{\texttt{manpage}}.
                        \item \textbf{\texttt{constants}:} Grant access to the \texttt{\allowbreak terminal\_escape\_sequences dictionary} containing \texttt{ANSI escape sequences} enabling colored output.
                        \item \textbf{\texttt{sys}:} This module allows us to print error messages to \texttt{STDERR} instead of \texttt{STDOUT} so that they can be easily redirected later on if needed with \texttt{2>/path/to/log}.
                        \item \textbf{\texttt{subprocess}:} This module enables the execution of commands through a shell \textbf{and} allows the caller to retrieve the command's output to \texttt{STDOUT} on top of its return code. This will let us retrieve a container's associated \texttt{PID}.
                        \item \textbf{\texttt{interface}:} This module will let us instantiate and add \texttt{interface\_inst} to the nodes we create.
                    \end{enumerate}

                \paragraph{Global Variables}
                    \begin{enumerate}
                        \item \textbf{\texttt{\allowbreak t\_colors - dictionary/string/string}:} This is a synonym for the \texttt{\allowbreak terminal\_escape\_sequences dictionary} we me mentioned before. It is used within calls to \texttt{print()} so that we can alter the terminal text's color allowing for a more visual information representation.
                    \end{enumerate}

                \paragraph{The \texttt{k\_bridge} Class}
                    This class represents a virtual bridge. Note the \texttt{k} stands for kernel as these bridges are part of the kernel itself.

                    \subparagraph{Class Attributes}
                        \begin{enumerate}
                            \item \textbf{\texttt{self.type - string}:} Object type identifier containing the \texttt{"bridge" string} for bridges. It is used within functions to check the type of object it is currently dealing with.
                            \item \textbf{\texttt{self.name - string}:} Bridge's name.
                            \item \textbf{\texttt{self.up - boolean}:} \texttt{True} if the bridge is currently up (i.e. ``switched on''). \texttt{False} otherwise.
                            \item \textbf{\texttt{self.subnet - string}:} Bridge's associated subnetwork given as the network address for said subnetwork together with the subnet mask in \texttt{CIDR} notation.
                        \end{enumerate}

                    \subparagraph{The \texttt{Constructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_birdge\_inst:} The actual bridge instance.
                                \item \texttt{name - string:} The bridge's name.
                                \item \texttt{subnet - string:} The subnetwork associated with this bridge.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will initialize the members of an \texttt{k\_bridge\_inst} and call the \texttt{\_activate\_bridge()} method.
                        \end{enumerate}

                    \subparagraph{The \texttt{\_activate\_bridge()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} After the bridge has been instantiated it must be brought up so that it can be operated normally. We do so through the \texttt{ip link} command, printing a message on success. Once the bridge is activated, the \texttt{self.up} attribute will be set to \texttt{True}.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_name()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the bridge's name.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_type()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} The \texttt{"bridge" string}.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_subnet()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the bridge's associated subnet in \texttt{CIDR} format.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{remove()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method shuts the bridge down. It will check it is indeed activated before doing so in an effort to prevent errors provoked by calling \texttt{ip link} with incorrect parameters (i.e. such as by trying to shutdown a bridge that is already down). This method will print a message to \texttt{STDOUT} informing whether the operation was a success or not.
                        \end{enumerate}

                    \subparagraph{The \texttt{Destructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - k\_bridge\_inst:} The actual bridge instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will just call \texttt{remove()}.
                        \end{enumerate}

                \paragraph{The \texttt{d\_node} Class}
                    This class represents a node implementing a virtual host. Note the \texttt{d} stands for docker.

                    \subparagraph{Class Attributes}
                        \begin{enumerate}
                            \item \textbf{\texttt{self.type - string}:} Object type identifier containing the \texttt{"node" string} for bridges. It is used within functions to check the type of object it is currently dealing with.
                            \item \textbf{\texttt{self.name - string}:} Node's name.
                            \item \textbf{\texttt{self.up - boolean}:} \texttt{True} if the bridge is currently up (i.e. ``switched on''). \texttt{False} otherwise.
                            \item \textbf{\texttt{self.pid - int}:} The associated container's \texttt{PID}. It is used when linking the container's network namespace to \texttt{/var/run/netns} so that we can easily access it afterwards.
                            \item \textbf{\texttt{self.interfaces - list/interface\_inst}:}  A list containing the instances of the interfaces belonging to this node.
                        \end{enumerate}

                    \subparagraph{The \texttt{Constructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                                \item \texttt{name - string:} The node's name.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will just initialize several members with the passed parameters whilst assigning sane defaults to others. It leverages the power of the \texttt{docker inspect} command to find the associated container's \texttt{PID}. It will also call \texttt{\_link\_net\_namespace()} to allow an easier handling of the container's namespace through the \texttt{ip} command.
                        \end{enumerate}

                    \subparagraph{The \texttt{\_link\_net\_namespace()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will create a symbolic link to the container's network namespace under \texttt{/var/run/netns} where the \texttt{ip} command will ``look for'' existing named namespaces. This method leverages the \texttt{self.pid} attribute that is initialized in the constructor to find the original location of the container's namespace so that it can later be linked.
                        \end{enumerate}

                    \subparagraph{The \texttt{\_set\_hostname()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will just set the container's hostname. It is essential to distinguish between the container's name and its hostname. The former is an identifier that only concerns docker, whilst the latter will be the machine's identifier from the point of view of the network. This method will make the latter the same as the former. What is more, this operation made us change the underscores (\texttt{\_}) in the original node names by hyphens (\texttt{-}): the former were not allowed on network hostnames.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_name()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{string} containing the node's name.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_type()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} The \texttt{"node" string}.
                            \item \textbf{Description:} Not applicable.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_subnets()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{list/string} containing the different subnetworks this node is connected to in \texttt{CIDR} format.
                            \item \textbf{Description:} This method will iterate over the \texttt{interface\_inst} contained in the \texttt{self.interfaces} attribute to then provide a list containing the subnetworks each of these \texttt{interface\_inst} belong to.
                        \end{enumerate}

                    \subparagraph{The \texttt{get\_interface()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                                \item \texttt{subnet - string - optional:} Specifies the subnetwork for which an associated \texttt{interface\_inst} should be returned.
                            \end{enumerate}
                            \item \textbf{Returns:} The following are evaluated in order.
                            \begin{enumerate}
                                \item A \texttt{list/interface\_inst} if the \texttt{subnet} parameter was not specified.
                                \item An \texttt{interface\_inst} associated to the subnetwork specified in the \texttt{subnet} parameter.
                                \item \texttt{None} if there is no interface associated with the subnetwork specified through the \texttt{subnet} parameter.
                            \end{enumerate}
                            \item \textbf{Description:} As seen on the \textbf{returns} section, the \texttt{subnet} parameter behaves like a switch. A \texttt{list} of \texttt{interface\_inst} will be returned if it is not specified by the caller. In case it is provided, it will return either an \texttt{interface\_inst} or \texttt{None} if there is no interface associated with the specified subnetwork.
                        \end{enumerate}

                    \subparagraph{The \texttt{create\_interface()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                                \item \texttt{if\_name - string:} Name of the interface to create.
                                \item \texttt{if\_subnet - string:} Subnet associated with the interface to create.
                                \item \texttt{o\_if - boolean:} Flag indicating whether the interface to create should be allowed to ``see'' other subnetworks.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will instantiate a new interface and add it to the node's \texttt{self.interfaces list}. The method's parameters will be passed directly to the \texttt{interface} class constructor.
                        \end{enumerate}

                    \subparagraph{The \texttt{reset\_interfaces()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method erases all the interfaces associated with the node through the \texttt{clear()} \footnote{\href{https://docs.python.org/3/tutorial/datastructures.html}{https://docs.python.org/3/tutorial/datastructures.html}} method of the \texttt{self.interfaces list}. This method will \textit{implicitly} call the destrucotr for each interface, thus effectively deleting the underlying \texttt{veths}.
                        \end{enumerate}

                    \subparagraph{The \texttt{stop()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} A \texttt{boolean} indicating whether the operation succeeded or not.
                            \item \textbf{Description:} This method is in charge of stopping the instance's associated docker container. We can do so thanks to the \texttt{docker stop} command. This method leverages a redirection to \texttt{/dev/null} so that the output generated by \texttt{docker stop} does not interfere with our own. This method will print a message both upon success and error.
                        \end{enumerate}

                    \subparagraph{The \texttt{remove()} Method}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method is in charge of entirely removing the associated container. It will call the \texttt{stop()} method as a container must be stopped before it can be removed through the \texttt{docker rm} command. First of all, the method will get rid of the interfaces as soon as possible so that, even if something goes wrong when deleting the container, it has no connection to a network that might still be alive. This will in fact isolate the container so that possible errors have no impact on the rest of the virtualized scenario. We will also update the \texttt{self.up} attribute and delete the link to the container's network namespace living under \texttt{/var/run/netns}. As usual we will print information relative to the command's outcome.
                        \end{enumerate}

                    \subparagraph{The \texttt{Destructor}}
                        \begin{enumerate}
                            \item \textbf{Parameters:}
                            \begin{enumerate}
                                \item \texttt{self - d\_node\_inst:} The actual node instance.
                            \end{enumerate}
                            \item \textbf{Returns:} Nothing.
                            \item \textbf{Description:} This method will call the \texttt{remove()} which will in turn delete the associated container. Given the definition of the \texttt{remove()} method this will later allow us to dismantle the entire network with a single order.
                        \end{enumerate}

    \section{Working Topologies}
