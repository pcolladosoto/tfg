\subsubsection{\texttt{Net\_machines.py}}
    This file plays a role quite similar to that of the \texttt{Subnet\_machines.py} file we described above. This file contains the definition of the class representing the routers we will use in our topologies. Even though routers, like nodes, are implemented as docker containers they behave in a slightly different way.\\

    Routers will implement the different firewalls we are to use through \textit{iptables} and they will always contain at least two interfaces (in contrast with nodes that will usually contain a single one). The differences between these two classes are motivated by these slight discrepancies in terms of functionality. We would like to point out that the syntax that one \textbf{must} adhere to when defining firewall rules has been set forth in section \ref{sec:fw-rules}.\\

    The lifecycle of routers is practically the same as that of nodes. The most noticeable difference might be how a router will usually assist to more interface additions and deletions throughout its lifespan.\\

    \begin{enumerate}
        \item The real instance is brought up.
        \item The object representing said instance is created.
        \item The object sits idle. Several of its parameters can be altered within this state, such as the number of interfaces.
        \item At some point, the object will be dismantled.
        \item The release of the object will trigger the removal of the associated real instance.
    \end{enumerate}

    \paragraph{Imported Libraries}
        \begin{enumerate}
            \item \textbf{\texttt{os}:} This module enables the execution of commands through a \texttt{sh} shell through the \texttt{os.system()} method. One can check the shell being spawned is indeed \texttt{sh} by running \texttt{\allowbreak os.system("echo \$0")} or bu querying the following \href{https://linux.die.net/man/3/system}{\texttt{manpage}}.
            \item \textbf{\texttt{constants}:} Grant access to the \texttt{\allowbreak terminal\_escape\_sequences dictionary} containing \texttt{ANSI escape sequences} enabling colored output.
            \item \textbf{\texttt{sys}:} This module allows us to print error messages to \texttt{STDERR} instead of \texttt{STDOUT} so that they can be easily redirected later on if needed with \texttt{2>/path/to/log}.
            \item \textbf{\texttt{subprocess}:} This module enables the execution of commands through a shell \textbf{and} allows the caller to retrieve the command's output to \texttt{STDOUT} on top of its return code. This will let us retrieve a container's associated \texttt{PID}.
            \item \textbf{\texttt{interface}:} This module will let us instantiate and add \texttt{interface\_inst} to the nodes we create.
        \end{enumerate}

    \paragraph{Global Variables}
        \begin{enumerate}
            \item \textbf{\texttt{\allowbreak t\_colors - dictionary/string/string}:} This is a synonym for the \texttt{\allowbreak terminal\_escape\_sequences dictionary} we me mentioned before. It is used within calls to \texttt{print()} so that we can alter the terminal text's color allowing for a more visual information representation.
        \end{enumerate}

    \paragraph{The \texttt{d\_router} Class}
        This class represents a virtual router. Note the \texttt{`d'} stands for docker.

        \subparagraph{Class Attributes}
            \begin{enumerate}
                \item \textbf{\texttt{self.type - string}:} Object type identifier containing the \texttt{"router" string} for routers. It is used within functions to check the type of object it is currently dealing with.
                \item \textbf{\texttt{self.name - string}:} Router's name.
                \item \textbf{\texttt{self.pid - int}:} The associated container's \texttt{PID}. It is used when linking the container's network namespace to \texttt{/var/run/netns} so that we can easily access it afterwards.
                \item \textbf{\texttt{self.interfaces - list/interface\_inst}:}  A list containing the instances of the interfaces belonging to this router.
                \item \textbf{\texttt{fw\_rules - dictionary/string/list}:} Firewall rules configured for this router. Note that even though the ``logical'' format is exactly the same as the one presented on section \ref{sec:fw-rules}, the node names are translated to \textit{IPs} by the caller when this member is initialized. This implies that the ``real'' entries we are to work with internally are of the form \texttt{("source\_ip", "destination\_ip", bidirectional?)} instead of \texttt{("source\_node", "destination\_node", bidirectional?)}.
            \end{enumerate}

        \subparagraph{The \texttt{Constructor}}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                    \item \texttt{name - string:} The router's name.
                \end{enumerate}
                \item \textbf{Returns:} Nothing.
                \item \textbf{Description:} This method will just initialize several members with the passed parameters whilst assigning sane defaults to others. It leverages the power of the \texttt{docker inspect} command to find the associated container's \texttt{PID}. It will also call \texttt{\_link\_net\_namespace()} to allow an easier handling of the container's namespace through the \texttt{ip} command. It finally calls \texttt{\_set\_hostname()} to configure the router's identity from the network's perspective.
            \end{enumerate}

        \subparagraph{The \texttt{\_link\_net\_namespace()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                \end{enumerate}
                \item \textbf{Returns:} Nothing.
                \item \textbf{Description:} This method will create a symbolic link to the container's network namespace under \texttt{/var/run/netns} where the \texttt{ip} command will ``look for'' existing named namespaces. This method leverages the \texttt{self.pid} attribute that is initialized in the constructor to find the original location of the container's namespace so that it can later be linked.
            \end{enumerate}

        \subparagraph{The \texttt{\_set\_hostname()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                \end{enumerate}
                \item \textbf{Returns:} Nothing.
                \item \textbf{Description:} This method will just set the container's hostname. It is essential to distinguish between the container's name and its hostname. The former is an identifier that only concerns docker, whilst the latter will be the machine's identifier from the point of view of the network. This method will make the latter the same as the former. What is more, this operation made us change the underscores (\texttt{\_}) in the original node names by hyphens (\texttt{-}): the former were not allowed on network hostnames.
            \end{enumerate}

        \subparagraph{The \texttt{get\_name()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                \end{enumerate}
                \item \textbf{Returns:} A \texttt{string} containing the router's name.
                \item \textbf{Description:} Not applicable.
            \end{enumerate}

        \subparagraph{The \texttt{get\_type()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                \end{enumerate}
                \item \textbf{Returns:} The \texttt{"router" string}.
                \item \textbf{Description:} Not applicable.
            \end{enumerate}

        \subparagraph{The \texttt{get\_subnets()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                \end{enumerate}
                \item \textbf{Returns:} A \texttt{list/string} containing the different subnetworks this node is connected to in \textit{CIDR} format.
                \item \textbf{Description:} This method will iterate over the \texttt{interface\_inst} contained in the \texttt{self.interfaces} attribute to then provide a list containing the subnetworks each of these \texttt{interface\_inst} belong to.
            \end{enumerate}

        \subparagraph{The \texttt{get\_interface()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                    \item \texttt{subnet - string - optional:} Specifies the subnetwork for which an associated \texttt{interface\_inst} should be returned.
                \end{enumerate}
                \item \textbf{Returns:} The following are evaluated in order.
                \begin{enumerate}
                    \item A \texttt{list/interface\_inst} if the \texttt{subnet} parameter was not specified.
                    \item An \texttt{interface\_inst} associated to the subnetwork specified in the \texttt{subnet} parameter.
                    \item \texttt{None} if there is no interface associated with the subnetwork specified through the \texttt{subnet} parameter.
                \end{enumerate}
                \item \textbf{Description:} As seen on the \textbf{returns} section, the \texttt{subnet} parameter behaves like a switch. A \texttt{list} of \texttt{interface\_inst} will be returned if it is not specified by the caller. In case it is provided, it will return either an \texttt{interface\_inst} or \texttt{None} if there is no interface associated with the specified subnetwork.
            \end{enumerate}

        \subparagraph{The \texttt{create\_interface()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                    \item \texttt{if\_name - string:} Name of the interface to create.
                    \item \texttt{if\_subnet - string:} Subnet associated with the interface to create.
                    \item \texttt{o\_if - boolean:} Flag indicating whether the interface to create should be allowed to ``see'' other subnetworks.
                \end{enumerate}
                \item \textbf{Returns:} Nothing.
                \item \textbf{Description:} This method will instantiate a new interface and add it to the node's \texttt{self.interfaces list}. The method's parameters will be passed directly to the \texttt{interface} class constructor.
            \end{enumerate}

        % Cite the first footnote as the one used in the Subnet_machines.tex file! through bib!
            % More info -> https://tex.stackexchange.com/questions/187863/how-to-refer-to-same-footnote-twice-in-revtex
        \subparagraph{The \texttt{reset\_interfaces()} Method}
            \begin{enumerate}
                \item \textbf{Parameters:}
                \begin{enumerate}
                    \item \texttt{self - d\_router\_inst:} The actual router instance.
                    \item \texttt{subnet - string - optional:} The subnetwork associated to the interface that should be reset.
                \end{enumerate}
                \item \textbf{Returns:} A \texttt{boolean} indicating whether the operation completed successfully or not.
                \item \textbf{Description:} If the caller does not specify a \texttt{subnet} parameter, this method erases all the interfaces associated with the router whilst also removing the associated ``real instances'' from the host machine. This can easily be accomplished through the \texttt{clear()} \footnote{\href{https://docs.python.org/3/tutorial/datastructures.html}{https://docs.python.org/3/tutorial/datastructures.html}} method defined for \texttt{lists}, such as the \texttt{self.interfaces} attribute due to the destructor we defined for the \texttt{interface} class. If the caller specifies a subnetwork, the method will look for the interface belonging to that subnetwork and \texttt{remove()} it from the \texttt{self.interfaces} attribute. This will, as before, trigger the deletion of the ``real interface''. The method will return \texttt{True} if either all the interfaces were deleted (i.e. no \texttt{subnet} was specified) or if the one specified through the \texttt{subnet} parameter was found and deleted as well. If the caller specified an interface belonging to a specific subnet and it was not found the method will return \texttt{False}, signaling an error.
            \end{enumerate}
